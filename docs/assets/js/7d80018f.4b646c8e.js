"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[428],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,f=d["".concat(s,".").concat(m)]||d[m]||p[m]||r;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5454:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return u},default:function(){return d}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=["components"],l={sidebar_position:2,title:"Types"},s=void 0,c={unversionedId:"analyses/types",id:"version-0.3/analyses/types",isDocsHomePage:!1,title:"Types",description:"Core analyses",source:"@site/versioned_docs/version-0.3/analyses/types.md",sourceDirName:"analyses",slug:"/analyses/types",permalink:"/analyses/types",editUrl:"https://github.com/slicap/slicap/edit/main/website/versioned_docs/version-0.3/analyses/types.md",tags:[],version:"0.3",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Types"},sidebar:"version-0.3/docSidebar",previous:{title:"Structure",permalink:"/analyses/structure"},next:{title:"Design goals",permalink:"/design-notes/goals"}},u=[{value:"Core analyses",id:"core-analyses",children:[{value:"<code>.transfer()</code>",id:"transfer",children:[]},{value:"<code>.solve()</code>",id:"solve",children:[]},{value:"<code>.noise()</code>",id:"noise",children:[]},{value:"<code>.dcvar()</code>",id:"dcvar",children:[]},{value:"<code>.mna_matrix()</code>",id:"mna_matrix",children:[]}]},{value:"Detector types",id:"detector-types",children:[]},{value:"Advanced Use",id:"advanced-use",children:[{value:"<code>.sample()</code>",id:"sample",children:[]}]}],p={toc:u};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"core-analyses"},"Core analyses"),(0,r.kt)("p",null,"SLiCAP's core analysis methods can help you obtain information of the following type:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},".transfer()"),": transfer functions"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},".solve()"),": nodal voltages and branch currents"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},".noise()"),": any information related to noise in the circuit"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},".dcvar()"),": any information related to the effects of component or operating point variation"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},".mna_matrix()"),": the MNA matrix representation of the circuit")),(0,r.kt)("p",null,"You can enter an optional argument between brackets to specify the simulation type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# default\nmy_circuit.transfer(sim='symbolic')\n\n# if the numeric value of a symbol is known, it'll replace the symbol\nmy_circuit.transfer(sim='numeric')  \n")),(0,r.kt)("h3",{id:"transfer"},(0,r.kt)("inlineCode",{parentName:"h3"},".transfer()")),(0,r.kt)("p",null,"To obtain information about the transfer between 2 ports called ",(0,r.kt)("inlineCode",{parentName:"p"},"port_in")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"port_out"),", use the following syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"tf = my_circuit.transfer().from('port_in').at('port_out')\n")),(0,r.kt)("p",null,"The object ",(0,r.kt)("inlineCode",{parentName:"p"},"tf")," contains an  ",(0,r.kt)("em",{parentName:"p"},"unevaluated")," transfer function. You can evaluate this transfer function by using the following methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"tf.laplace # obtain the transfer function in the laplace domain\ntf.pz      # obtain the poles and zeroes of the transfer\ntf.dc      # obtain the DC transfer\ntf.impulse # obtain the impulse/step response after the transfer\ntf.step    # obtain the impulse/step response after the transfer\n")),(0,r.kt)("h3",{id:"solve"},(0,r.kt)("inlineCode",{parentName:"h3"},".solve()")),(0,r.kt)("p",null,"SLiCAP can do nodal analysis. If you want to obtain a nodal voltage or a branch current, you can use the following syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# obtain node voltage (w.r.t ground) of a node called 'out'\nresult = my_circuit.solve().at('out')\n\n# obtain branch current through a resistor 'R1'\nresult = my_circuit.solve().through('R1')\n")),(0,r.kt)("p",null,"The object ",(0,r.kt)("inlineCode",{parentName:"p"},"result")," contains an  ",(0,r.kt)("strong",{parentName:"p"},"unevaluated ")," nodal analysis. You can evaluate this result by using the following methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"result.laplace # obtain the transfer function in the laplace domain\nresult.dc      # obtain the DC transfer\nresult.time    # obtain a time-domain expression\n")),(0,r.kt)("h3",{id:"noise"},(0,r.kt)("inlineCode",{parentName:"h3"},".noise()")),(0,r.kt)("p",null,"SLiCAP can find noise voltages and currents as well as noise transfers for you."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# find noise voltage at a node called 'out'\nresult = my_circuit.noise().at('out')\n\n# find noise current through a branch called 'R_L'\nresult = my_circuit.noise().through('R_L')\n")),(0,r.kt)("p",null,"You can refer output noise back to the input (or any other circuit node/branch)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# find noise voltage at the output (in this example: node 'out')\n# then, refer it back to the input (in this example: node 'in')\nresult = my_circuit.noise().at('out').refer_to('in')\n")),(0,r.kt)("p",null,"You can choose which noise sources to transfer to the output."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# find noise voltage at a node called 'out' as a result of the\n# noise source 'R1'.\nresult = my_circuit.noise().from('R1').at('out')\n")),(0,r.kt)("p",null,"The object ",(0,r.kt)("inlineCode",{parentName:"p"},"result")," contains an  ",(0,r.kt)("strong",{parentName:"p"},"unevaluated ")," noise analysis. You can evaluate this result by using the following methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"result.psd # obtain noise as noise PSD\n")),(0,r.kt)("h3",{id:"dcvar"},(0,r.kt)("inlineCode",{parentName:"h3"},".dcvar()")),(0,r.kt)("p",null,"Tolerances/variances/distributions of component values can change circuit behavior. SLiCAP can analyse the extend to which DC circuit behavior is affected."),(0,r.kt)("p",null,"Just like noise analysis, DC variation analysis considers the variance of component tolerances, and the transfer from that component to a node/branch."),(0,r.kt)("p",null,"Hence, the syntax of dcvar analysis is identical to that of noise, but instead of .noise() you type .dcvar()."),(0,r.kt)("p",null,"Returned unevaluated analysis results do have different evaluations, though."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"result.laplace # obtain the transfer function in the laplace domain\nresult.dc      # obtain the DC transfer\nresult.time    # obtain a time-domain expression\n")),(0,r.kt)("h3",{id:"mna_matrix"},(0,r.kt)("inlineCode",{parentName:"h3"},".mna_matrix()")),(0,r.kt)("p",null,"You can obtain the Modified Nodal Analysis (MNA) Matrix of a circuit by using the .mna_matrix() method as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# this commmand returns a sympy array with laplace variable s\nmy_circuit.mna_matrix()\n")),(0,r.kt)("h2",{id:"detector-types"},"Detector types"),(0,r.kt)("p",null,"You use the detector type specifiers to specify the output quantity of the simulation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},".at(node)                # voltage at a node\n.into(terminal)          # current into a terminal\n.between(node_p, node_n) # differential voltage between two nodes (node_p - node_n)\n.over(bipole)            # voltage over a bipole\n.through(bipole)         # current through a bipole\n")),(0,r.kt)("p",null,"You can use lists to specify multiple detectors of the same type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},".at([node1, node2])\n.into([terminal1, terminal2])\n.between([node1_p, node2_p], [node1_n, node2_n])\n.over([bipole1, bipole2])\n.through([bipole1, bipole2])\n")),(0,r.kt)("h2",{id:"advanced-use"},"Advanced Use"),(0,r.kt)("h3",{id:"sample"},(0,r.kt)("inlineCode",{parentName:"h3"},".sample()")),(0,r.kt)("p",null,"Consider an analysis result that is a sympy expression in the time or s-domain. Using .sample() you can evaluate this function for a number of specified values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# example: tf = 4*t + 2\n# .sample() works with lists\nt_list = [1, 2, 3]\ntf.sample(t_list)\n>> tf = [6, 10, 14]\n\n# .sample() works with numpy arrays\ntf.sample(np.array([1, 2, 3]))\n>> tf = [6, 10, 14]\n")))}d.isMDXComponent=!0}}]);